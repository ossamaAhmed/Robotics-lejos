package ev3Navigator;

import lejos.hardware.motor.EV3LargeRegulatedMotor;
import ev3Odometer.*;
import ev3Ultrasonic.*;

public class Navigator extends Thread {
    // Variables
    private Odometer odometer;
    private UltrasonicPoller usPoller;
    private static EV3LargeRegulatedMotor leftMotor;
    private static EV3LargeRegulatedMotor rightMotor;
    private double track;
    private double wr;
    private boolean isNavigating;
    private int FORWARD_SPEED = 150;
    private int ROTATE_SPEED = 50;
    private double x;
    private double y;

    public Navigator(Odometer odometer, UltrasonicPoller usPoller,
   		 EV3LargeRegulatedMotor leftMotor,
   		 EV3LargeRegulatedMotor rightMotor, double track, double wr) {
   	 this.odometer = odometer;
   	 this.usPoller = usPoller;
   	 this.leftMotor = leftMotor;
   	 this.rightMotor = rightMotor;
   	 this.track = track;
   	 this.wr = wr;
   	 // Reset Motors
    }

    public void run() {
    	 for (EV3LargeRegulatedMotor motor : new EV3LargeRegulatedMotor[] {
       			 leftMotor, rightMotor }) {
       		 motor.stop();
       		 motor.setAcceleration(2000);
       	 }
   	 while (true) {
   		 move();

   	 }

    }
    
    public void move(){
   	 // First find the required heading angle
   			 double dx = this.x-odometer.getX();
   			 double dy = this.y-odometer.getY();
   			 double theta = 0;
   			 double distance =Math.sqrt((Math.pow(dx, 2)+Math.pow(dy,2)));
   			 
   			 if (this.x > 0)
   			 {
   				 theta = Math.toDegrees(Math.atan(dy/dx));
   			 }
   			 
   			 else if (this.x <0 && this.y>0){
   				 theta = Math.toDegrees(Math.atan(dy/dx)) + 180;
   			 }
   			 
   			 else if (this.x <0 && this.y<0){
   				 theta = Math.toDegrees(Math.atan(dy/dx)) - 180;
   			 }
   			 
   			 //
   			 
   			 //Turn to the desired angle before going straight.
   			 if (distance > 1){
   			 //turnTo(theta);
   			 
   			 leftMotor.setSpeed(FORWARD_SPEED);
   			 rightMotor.setSpeed(FORWARD_SPEED);
   			leftMotor.rotate(convertDistance(wr,20),true);
   			rightMotor.rotate(convertDistance(wr,20),true);
   			 }
   			 
   			 else{
   				 leftMotor.setSpeed(0);
   	   			 rightMotor.setSpeed(0);
   				 leftMotor.stop();
   				 rightMotor.stop();
   			 }
   			 
   	 
    }

    public void travelTo(double x, double y) {
   	 this.x = x;
   	 this.y = y;
   	 
    }

    public void turnTo(double theta) {
   	 double d = theta - odometer.getThetaDegrees();

   	 // Find minimum angle
   	 if (d >= -180 || d <= 180) {
   		 // Leave d as is
   	 } else if (d < -180) {
   		 d = d + 360;
   	 } else if (d > 180) {
   		 d = d - 360;
   	 }
   	 //

   	 leftMotor.setSpeed(ROTATE_SPEED);
   	 rightMotor.setSpeed(ROTATE_SPEED);
   	 leftMotor.rotate(convertAngle(wr, track, d), true);
   	 rightMotor.rotate(-convertAngle(wr, track, d), false);
    }

    public boolean isNavigating() {
   	 return this.isNavigating;
    }

    public int getDistance() {
   	 return this.usPoller.getDistance();
    }

    private static int convertDistance(double radius, double distance) {
   	 return (int) ((180.0 * distance) / (Math.PI * radius));
    }

    private static int convertAngle(double radius, double width, double angle) {
   	 return convertDistance(radius, Math.PI * width * angle / 360.0);
    }

}



package ev3Navigator;

import lejos.hardware.motor.EV3LargeRegulatedMotor;
import ev3Odometer.*;
import ev3Ultrasonic.*;

public class Navigator extends Thread {
    // Variables
    private Odometer odometer;
    private UltrasonicPoller usPoller;
    private static EV3LargeRegulatedMotor leftMotor;
    private static EV3LargeRegulatedMotor rightMotor;
    private double track;
    private double wr;
    private boolean isNavigating;
    private int FORWARD_SPEED = 200;
    private int ROTATE_SPEED = 50;
    private double desiredX;
    private double desiredY;

    public Navigator(Odometer odometer, UltrasonicPoller usPoller, EV3LargeRegulatedMotor leftMotor,
   		 EV3LargeRegulatedMotor rightMotor, double track, double wr) {
   	 this.odometer = odometer;
   	 this.usPoller = usPoller;
   	 this.leftMotor = leftMotor;
   	 this.rightMotor = rightMotor;
   	 this.track = track;
   	 this.wr = wr;
   	 // Reset Motors
    }

    public void run() {
    }

    public void move() {
   	 double dx = this.desiredX - odometer.getX();
   	 double dy = this.desiredY - odometer.getY();
   	 double distance = Math.sqrt((Math.pow(dx, 2) + Math.pow(dy, 2)));
   	 double distanceFromBlock= this.usPoller.getDistance();
   	 if(distanceFromBlock<15){
   		leftMotor.setSpeed(ROTATE_SPEED);
      	rightMotor.setSpeed(ROTATE_SPEED);
   		turnTo(odometer.getThetaDegrees()+90);
   		leftMotor.setSpeed(FORWARD_SPEED);
      	rightMotor.setSpeed(FORWARD_SPEED);
      	leftMotor.rotate(convertDistance(wr, 15), true);
      	rightMotor.rotate(convertDistance(wr, 15), false);

      	leftMotor.setSpeed(ROTATE_SPEED);
      	rightMotor.setSpeed(ROTATE_SPEED);
   		turnTo(odometer.getThetaDegrees()-90);
   		leftMotor.setSpeed(FORWARD_SPEED);
      	rightMotor.setSpeed(FORWARD_SPEED);
      	leftMotor.rotate(convertDistance(wr, 15), true);
      	rightMotor.rotate(convertDistance(wr, 15), false);
      	
    	leftMotor.setSpeed(ROTATE_SPEED);
      	rightMotor.setSpeed(ROTATE_SPEED);
   		turnTo(odometer.getThetaDegrees()-90);
   		leftMotor.setSpeed(FORWARD_SPEED);
      	rightMotor.setSpeed(FORWARD_SPEED);
      	leftMotor.rotate(convertDistance(wr, 15), true);
      	rightMotor.rotate(convertDistance(wr, 15), false);
      	
    	leftMotor.setSpeed(ROTATE_SPEED);
      	rightMotor.setSpeed(ROTATE_SPEED);
   		turnTo(odometer.getThetaDegrees()+90);
   		leftMotor.setSpeed(FORWARD_SPEED);
      	rightMotor.setSpeed(FORWARD_SPEED);
      	leftMotor.rotate(convertDistance(wr, 15), true);
      	rightMotor.rotate(convertDistance(wr, 15), false);

      	
   		
   	 }

   	 leftMotor.setSpeed(FORWARD_SPEED);
   	 rightMotor.setSpeed(FORWARD_SPEED);
   	 leftMotor.forward();
   	 rightMotor.forward();
   	 if (distance < 1) {
   		 rightMotor.setSpeed(0);
   		 leftMotor.setSpeed(0);
   		 leftMotor.forward();
   		 rightMotor.forward();
   		 isNavigating = false;
   	 }
    }

    public void travelTo(double x, double y) {
   	 this.desiredX = x;
   	 this.desiredY = y;
   	 isNavigating = true;
   	 // Find new heading -> convert to min angle to turn -> turn by this
   	 // angle
   	 turnTo(getMinAngle(getNewHeading()));
   	 while (this.isNavigating) {
   		 move();

   	 }

    }

    public void turnTo(double theta) {
   	 leftMotor.setSpeed(ROTATE_SPEED);
   	 rightMotor.setSpeed(ROTATE_SPEED);
   	 leftMotor.rotate(-convertAngle(wr, track, theta), true);
   	 rightMotor.rotate(convertAngle(wr, track, theta), false);
    }

    public boolean isNavigating() {
   	 return this.isNavigating;
    }

    public double getMinAngle(double theta) {

   	 double minAngle = theta - odometer.getThetaDegrees();
   	 // Find minimum angle
   	 if (minAngle >= -180 || minAngle <= 180) {
   		 // Leave d as is
   	 } else if (minAngle < -180) {
   		 minAngle = minAngle + 360;
   	 } else if (minAngle > 180) {
   		 minAngle = minAngle - 360;
   	 }
   	 //

   	 return minAngle;
    }

    public double getNewHeading() {
   	 double dx = this.desiredX - odometer.getX();
   	 double dy = this.desiredY - odometer.getY();
   	 double theta = 0;
   	 double distance = Math.sqrt((Math.pow(dx, 2) + Math.pow(dy, 2)));

   	 if (Math.abs(dx) > 0 && Math.abs(dx) < 2 && Math.abs(dy) > 0 && Math.abs(dy) < 2) {
   		 // Heading is close enough to where it should be, don't change
   		 // anything
   		 theta = odometer.getThetaDegrees();

   	 } else if (dx > 0) {
   		 theta = Math.toDegrees(Math.atan(dy / dx));

   	 }

   	 else if (dx < 0 && dy >= 0) {
   		 theta = Math.toDegrees(Math.atan(dy / dx)) + 180;

   	 }

   	 else if (dx < 0 && dy < 0) {
   		 theta = Math.toDegrees(Math.atan(dy / dx)) - 180;

   	 }
   	 return theta;
    }

    public int getDistance() {
   	 return this.usPoller.getDistance();
    }

    private static int convertDistance(double radius, double distance) {
   	 return (int) ((180.0 * distance) / (Math.PI * radius));
    }

    private static int convertAngle(double radius, double width, double angle) {
   	 return convertDistance(radius, Math.PI * width * angle / 360.0);
    }

}


